import{x as b,y as l,z as y,A as _,_ as d}from"./index-qexVuyB5.js";import{r as t}from"./react-vendor-BQWX9zlF.js";async function w(){return(await d(()=>import("./mockData-INJWuUSN.js"),[])).mockProcedures}async function m(){return(await d(()=>import("./mockData-INJWuUSN.js"),[])).mockReviews}const S=async()=>{try{return await b.getAll()}catch(e){return console.error("Ошибка загрузки процедур из Firebase:",e),await w()}return await new Promise(e=>setTimeout(e,500)),await w()},x=async()=>{try{return await l.getApproved()}catch(e){return console.error("Ошибка загрузки отзывов из Firebase:",e),await m()}return await new Promise(e=>setTimeout(e,300)),await m()},T=async e=>{try{return await _.create(e),{success:!0,message:"Ваша заявка успешно отправлена! Мы свяжемся с вами в ближайшее время."}}catch(r){return console.error("Ошибка отправки заявки в Firebase:",r),{success:!1,message:"Ошибка при отправке заявки. Попробуйте позже."}}return await new Promise(r=>setTimeout(r,1e3)),{success:!0,message:"Ваша заявка успешно отправлена! Мы свяжемся с вами в ближайшее время."}},k=async e=>{try{const r=await l.create({clientName:e.clientName,procedureId:e.procedureId,procedureName:e.procedureName,rating:e.rating,text:e.text,date:new Date().toISOString().split("T")[0]});return await y.upsert(r,{phone:e.phone}),{success:!0,message:"Спасибо! Отзыв отправлен и появится на сайте после модерации."}}catch(r){return console.error("Ошибка отправки отзыва в Firebase:",r),{success:!1,message:"Ошибка при отправке отзыва. Попробуйте позже."}}return{success:!0,message:"Спасибо! Отзыв сохранён локально (режим без Firebase)."}};function E(e,r){return e?Date.now()-e>r:!0}function O(e,r=150){const[o,s]=t.useState(!1);return t.useEffect(()=>{if(!e){s(!1);return}const n=window.setTimeout(()=>s(!0),r);return()=>window.clearTimeout(n)},[e,r]),o}function A(e){const{root:r=null,rootMargin:o="0px",threshold:s=0,once:n=!0}=e||{},[p,a]=t.useState(!1),u=t.useRef(null),f=t.useRef(null),v=t.useCallback(c=>{u.current=c},[]);return t.useEffect(()=>{const c=u.current;if(!c)return;if(typeof IntersectionObserver>"u"){a(!0);return}f.current?.disconnect();const i=new IntersectionObserver(g=>{!!g[0]?.isIntersecting?(a(!0),n&&i.disconnect()):n||a(!1)},{root:r,rootMargin:o,threshold:s});return f.current=i,i.observe(c),()=>{i.disconnect()}},[r,o,s,n]),{ref:v,inView:p}}export{x as a,O as b,T as c,S as f,E as i,k as s,A as u};
