import{F as b,G as l,H as y,J as _,_ as d}from"./index-hyN2hRuu.js";import{r as t}from"./react-vendor-BQWX9zlF.js";async function w(){return(await d(()=>import("./mockData-INJWuUSN.js"),[])).mockProcedures}async function m(){return(await d(()=>import("./mockData-INJWuUSN.js"),[])).mockReviews}const P=async()=>{try{return await b.getAll()}catch(e){return console.error("Ошибка загрузки процедур из Firebase:",e),await w()}return await new Promise(e=>setTimeout(e,500)),await w()},k=async()=>{try{return await l.getApproved()}catch(e){return console.error("Ошибка загрузки отзывов из Firebase:",e),await m()}return await new Promise(e=>setTimeout(e,300)),await m()},x=async e=>{try{return await _.create(e),{success:!0,message:"Ваша заявка успешно отправлена! Мы свяжемся с вами в ближайшее время."}}catch(r){return console.error("Ошибка отправки заявки в Firebase:",r),{success:!1,message:"Ошибка при отправке заявки. Попробуйте позже."}}return{success:!1,message:"Заявка не отправлена: Firebase не настроен для этого окружения."}},E=async e=>{try{const r=await l.create({clientName:e.clientName,procedureId:e.procedureId,procedureName:e.procedureName,rating:e.rating,text:e.text,date:new Date().toISOString().split("T")[0]});return await y.upsert(r,{phone:e.phone}),{success:!0,message:"Спасибо! Отзыв отправлен и появится на сайте после модерации."}}catch(r){return console.error("Ошибка отправки отзыва в Firebase:",r),{success:!1,message:"Ошибка при отправке отзыва. Попробуйте позже."}}return{success:!0,message:"Спасибо! Отзыв сохранён локально (режим без Firebase)."}};function F(e,r){return e?Date.now()-e>r:!0}function T(e,r=150){const[o,s]=t.useState(!1);return t.useEffect(()=>{if(!e){s(!1);return}const n=window.setTimeout(()=>s(!0),r);return()=>window.clearTimeout(n)},[e,r]),o}function O(e){const{root:r=null,rootMargin:o="0px",threshold:s=0,once:n=!0}=e||{},[p,a]=t.useState(!1),u=t.useRef(null),f=t.useRef(null),v=t.useCallback(c=>{u.current=c},[]);return t.useEffect(()=>{const c=u.current;if(!c)return;if(typeof IntersectionObserver>"u"){a(!0);return}f.current?.disconnect();const i=new IntersectionObserver(g=>{!!g[0]?.isIntersecting?(a(!0),n&&i.disconnect()):n||a(!1)},{root:r,rootMargin:o,threshold:s});return f.current=i,i.observe(c),()=>{i.disconnect()}},[r,o,s,n]),{ref:v,inView:p}}export{k as a,T as b,x as c,P as f,F as i,E as s,O as u};
